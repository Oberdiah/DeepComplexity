package com.github.oberdiah.deepcomplexity.evaluation

import com.github.oberdiah.deepcomplexity.staticAnalysis.SetIndicator
import com.github.oberdiah.deepcomplexity.utilities.Utilities
import com.github.oberdiah.deepcomplexity.utilities.Utilities.toStringPretty
import com.intellij.psi.*

/**
 * If [temporary] is true this key will be removed from the context
 * after stacking. This is useful for tidying up keys that are only
 * added to aid resolution, such as parameters and `this`.
 */
sealed class Key(val temporary: Boolean = false) {
    abstract val ind: SetIndicator<*>

    /**
     * Uncertain Keys are keys that can be used as placeholders in `VariableExpressions`.
     * Not all keys fall into this category, for example `HeapKey`s and `ExpressionKey`s do not.
     */
    sealed class UncertainKey(temporary: Boolean = false) : Key(temporary), QualifierRef

    sealed class VariableKey(val variable: PsiVariable, temporary: Boolean = false) : UncertainKey(temporary) {
        override val ind: SetIndicator<*> = Utilities.psiTypeToSetIndicator(variable.type)
        override fun toString(): String = variable.toStringPretty()
        override fun equals(other: Any?): Boolean = other is VariableKey && this.variable == other.variable
        override fun hashCode(): Int = variable.hashCode()
    }

    class LocalVariableKey(variable: PsiLocalVariable) : VariableKey(variable)
    class ParameterKey(
        variable: PsiParameter,
        temporary: Boolean = false
    ) : VariableKey(variable, temporary)

    /**
     * This isn't a full key by itself, you'll need a [QualifierRef] as well and then will want to make a [QualifiedKey].
     */
    data class FieldRef(private val variable: PsiField) {
        override fun toString(): String = variable.toStringPretty()
        fun getElement(): PsiElement = variable
        val ind: SetIndicator<*> = Utilities.psiTypeToSetIndicator(variable.type)
    }

    /**
     * Things that can be qualifiers in a [QualifiedKey]. This is really just [HeapMarker]s and [UncertainKey]s.
     */
    sealed interface QualifierRef {
        val ind: SetIndicator<*>
        fun isNew(): Boolean =
            this is HeapMarker
                    || (this is QualifiedKey && this.qualifier.isNew())
    }

    data class QualifiedKey(val field: FieldRef, val qualifier: QualifierRef) : UncertainKey() {
        override val ind: SetIndicator<*> = this.field.ind
        override fun toString(): String = "$qualifier.$field"
    }

    data class ThisKey(val type: PsiType) : UncertainKey(temporary = true) {
        override val ind: SetIndicator<*> = Utilities.psiTypeToSetIndicator(type)
        override fun toString(): String = "this"
        override fun hashCode(): Int = 0
        override fun equals(other: Any?): Boolean = other is ThisKey
    }

    data class ReturnKey(override val ind: SetIndicator<*>) : UncertainKey() {
        override fun toString(): String = "Return value"
    }

    /**
     * Used to allow us to equate expressions.
     */
    data class ExpressionKey(val expr: Expr<*>) : Key() {
        override val ind: SetIndicator<*>
            get() = expr.ind

        override fun toString(): String = ExprToString.toExprKeyString(expr)
    }

    /**
     * Primarily for testing, doesn't have a specific element.
     */
    data class EphemeralKey(val key: Any) : Key() {
        override val ind: SetIndicator<*>
            get() = throw IllegalStateException("Ephemeral keys don't have a type.")

        override fun toString(): String = "#$key"

        companion object {
            private var KEY_INDEX = 0
            fun new(): EphemeralKey = EphemeralKey(KEY_INDEX++)
        }
    }

    fun isAutogenerated(): Boolean = isEphemeral() || isExpr()
    fun isEphemeral(): Boolean = this is EphemeralKey
    fun isExpr(): Boolean = this is ExpressionKey
    fun isNewlyCreated(): Boolean =
        this is QualifiedKey && this.qualifier.isNew()

    /**
     * When multiplying, we need to decide which one gets to live on.
     */
    fun importance(): Int {
        return when (this) {
            is VariableKey -> 6
            is QualifiedKey -> 5
            is ThisKey -> 4
            is ReturnKey -> 2
            is ExpressionKey -> 1
            is EphemeralKey -> 0
        }
    }

    /**
     * If the key is a variable (i.e. a Local Variable, Field, etc.), returns the variable.
     * If the key is a return statement, returns the method we're returning from.
     */
    fun getElement(): PsiElement {
        return when (this) {
            is VariableKey -> variable
            is QualifiedKey -> field.getElement()
            is ThisKey -> throw IllegalArgumentException("Cannot get element of this key")
            is ReturnKey -> throw IllegalArgumentException("Cannot get element of return key")
            is EphemeralKey -> throw IllegalArgumentException("Cannot get element of arbitrary key")
            is ExpressionKey -> throw IllegalArgumentException("Cannot get element of expression key")
        }
    }

    fun matchesElement(element: PsiElement): Boolean {
        return getElement() == element
    }
}