package com.github.oberdiah.deepcomplexity.evaluation

import com.github.oberdiah.deepcomplexity.evaluation.Context.Key
import com.github.oberdiah.deepcomplexity.staticAnalysis.DoubleSetIndicator
import com.github.oberdiah.deepcomplexity.staticAnalysis.SetIndicator
import com.github.oberdiah.deepcomplexity.staticAnalysis.constrainedSets.Bundle
import com.github.oberdiah.deepcomplexity.utilities.Utilities
import com.github.oberdiah.deepcomplexity.utilities.Utilities.toStringPretty
import com.intellij.psi.*

typealias Vars = Map<Key, Expr<*>>
typealias Heap = Map<Key.HeapKey, Vars>

class Context private constructor(
    val variables: Vars,
    val heap: Heap,
    val thisObj: Expr<*>?
) {
    sealed class Key {
        abstract class VariableKey<T : PsiVariable>(open val variable: T) : Key() {
            final override fun toString(): String = variable.toStringPretty()
        }

        data class LocalVariableKey(override val variable: PsiLocalVariable) : VariableKey<PsiLocalVariable>(variable)
        data class ParameterKey(override val variable: PsiParameter) : VariableKey<PsiParameter>(variable)
        data class FieldKey(override val variable: PsiField) : VariableKey<PsiField>(variable)

        @JvmInline
        value class HeapKey(val key: EphemeralKey) {
            companion object {
                fun new(): HeapKey {
                    return HeapKey(EphemeralKey.new())
                }
            }

            override fun toString(): String = "$key"
        }

        /**
         * This is the key representing a return type itself.
         * It behaves differently to other keys in that it applies backward when stacking.
         *
         * Normally, if you had two contexts in this order:
         *
         * ```
         * { a = if (x > 5) { 0 } else { a } }
         * { a = a + 5 }
         * ```
         *
         * The latter one would inherit the former's variables, and you'd end up with:
         *
         * ```
         * { a = (if (x > 5) { 0 } else { a }) + 5 }
         * ```
         *
         * However, if `a` was instead a `Method`, you'd end up with:
         *
         * ```
         * { a = if (x > 5) { 0 } else { a + 5 } }
         * ```
         * e.g. the rest of the method would get inserted into the context.
         *
         * It has a type associated with it so that we can perform implicit casts to it.
         */
        data class ReturnKey(val type: SetIndicator<*>) : Key() {
            companion object {
                val Me = ReturnKey(DoubleSetIndicator)
            }

            override fun toString(): String = "Return value"
            override fun hashCode(): Int = 0
            override fun equals(other: Any?): Boolean = other is ReturnKey
        }

        /**
         * Used to allow us to equate expressions.
         */
        data class ExpressionKey(val expr: Expr<*>) : Key() {
            override fun toString(): String = ExprToString.toExprKeyString(expr)
        }

        /**
         * Primarily for testing, doesn't have a specific element.
         */
        data class EphemeralKey(val key: Any) : Key() {
            override fun toString(): String = "#$key"

            companion object {
                var KEY_INDEX = 0
                fun new(): EphemeralKey {
                    return EphemeralKey(KEY_INDEX++)
                }
            }
        }

        open val ind: SetIndicator<*>
            get() {
                return when (this) {
                    is ExpressionKey -> this.expr.ind
                    is ReturnKey -> type
                    is VariableKey<*> -> Utilities.psiTypeToSetIndicator(variable.type)
                    else -> throw IllegalArgumentException("Cannot get indicator for $this")
                }
            }

        fun isAutogenerated(): Boolean = isEphemeral() || isExpr()
        fun isEphemeral(): Boolean = this is EphemeralKey
        fun isReturnKey(): Boolean = this is ReturnKey
        fun isExpr(): Boolean = this is ExpressionKey

        /**
         * When multiplying, we need to decide which one gets to live on.
         */
        fun importance(): Int {
            return when (this) {
                is VariableKey<*> -> 3
                is ReturnKey -> 2
                is ExpressionKey -> 1
                is EphemeralKey -> 0
            }
        }

        /**
         * If the key is a variable (i.e. a Local Variable, Field, etc.), returns the variable.
         * If the key is a return statement, returns the method we're returning from.
         */
        fun getElement(): PsiElement {
            return when (this) {
                is VariableKey<*> -> variable
                is ReturnKey -> throw IllegalArgumentException("Cannot get element of return key")
                is EphemeralKey -> throw IllegalArgumentException("Cannot get element of arbitrary key")
                is ExpressionKey -> throw IllegalArgumentException("Cannot get element of expression key")
            }
        }

        fun matchesElement(element: PsiElement): Boolean {
            return getElement() == element
        }
    }

    companion object {
        fun new(heap: Heap, thisObj: Expr<*>?): Context = Context(
            variables = emptyMap(),
            heap = heap,
            thisObj = thisObj
        )

        /**
         * You won't want this often, in nearly all cases it makes sense
         * to at least inherit the heap.
         */
        fun brandNew(): Context = new(emptyMap(), null)

        /**
         * Combines two contexts at the same 'point in time' e.g. a branching if statement.
         * This does not and cannot resolve any unresolved expressions as these two statements
         * are independent of each other.
         *
         * You must define how to resolve conflicts.
         *
         * `a` and `b` (The two contexts) must not be used again after this operation.
         */
        fun combine(a: Context, b: Context, how: (a: Expr<*>, b: Expr<*>) -> Expr<*>): Context {
            fun mergeMaps(a: Vars, b: Vars, how: (a: Expr<*>, b: Expr<*>) -> Expr<*>): Vars =
                (a.keys + b.keys)
                    .associateWith { key ->
                        val aVal = a[key] ?: VariableExpression<Any>(key)
                        val bVal = b[key] ?: VariableExpression<Any>(key)
                        // This equality is probably not very cheap.
                        // I'm sure that can be improved in the future.
                        if (aVal == bVal) {
                            aVal
                        } else {
                            how(aVal, bVal)
                        }
                    }

            // Merge the variables.
            val newVariables = mergeMaps(a.variables, b.variables, how)

            // Merge the heaps.
            val newHeap = (a.heap.keys + b.heap.keys).associateWith { heapKey ->
                mergeMaps(
                    a.heap[heapKey] ?: emptyMap(),
                    b.heap[heapKey] ?: emptyMap(),
                    how
                )
            }

            assert(a.thisObj == b.thisObj) {
                "How? The `this` object should surely be the same in both contexts?"
            }

            return Context(
                newVariables,
                heap = newHeap,
                thisObj = a.thisObj
            )
        }
    }

    val returnValue: Expr<*>?
        get() = variables[Key.ReturnKey.Me]

    override fun toString(): String {
        val variablesString =
            variables.entries.joinToString("\n") { entry ->
                val expr = entry.value
                val key = entry.key

                "$key:\n${expr.toString().prependIndent()}"
            }
        return "Context: {\n${variablesString.prependIndent()}\n}"
    }

    fun clone(): Context = Context(variables, heap, thisObj)

    fun debugKey(key: Key): String {
        return variables[key]?.dStr() ?: "Key not found"
    }

    fun canResolve(variable: VariableExpression<*>): Boolean {
        return variables.containsKey(variable.key)
    }

    fun evaluateKey(key: Key): Bundle<*> {
        val expr = variables[key] ?: throw IllegalArgumentException("Key $key not found in context")
        return expr.evaluate(ExprEvaluate.Scope())
    }

    fun getVar(element: Key): Expr<*> {
        return variables[element] ?: VariableExpression<Any>(element)
    }

    fun withHeap(heap: Heap): Context {
        return Context(variables, this.heap + heap, thisObj)
    }

    fun withThis(thisObj: Expr<*>?): Context {
        return Context(variables, heap, thisObj)
    }

    /**
     * Performs a cast if necessary.
     */
    fun withVar(lExpr: LValueExpr<*>, rExpr: Expr<*>): Context {
        assert(rExpr.iterateTree().none { it is LValueExpr<*> }) {
            "Cannot assign an LValueExpr to a variable: $lExpr = $rExpr. Try using `.resolveLValues(context)` on it first."
        }

        val qualifier = lExpr.qualifier
        val fieldKey = lExpr.key

        if (qualifier == null) {
            return withVar(lExpr.key, rExpr)
        }

        /**
         * This does look a bit scary, so I'll try to walk you through it:
         * Essentially, a qualifier may not just be a simple ClassExpression.
         * In the simplest case it is, and this all becomes a lot easier, but in the general case
         * it may be any complicated expression.
         * Let's go with the following example:
         * ```
         * a = new C(2);
         * b = new C(3);
         * ((x > 0) ? a : b).x = 5
         * ```
         * Now, the only objects we should be touching with our operation are `a` and `b`, so we gather
         * them first into [heapKeysInvolved]. That part's simple enough.
         *
         * Then, for the heaps we want to modify, we take our qualifier as specified above, and replace
         * `a` and `b` with either:
         *      a) The value already at that object, effectively turning `b` into `b.x`
         *      b) The value that we're setting this field to
         *  depending on whether the object we're modifying on the heap is the object being replaced in the
         *  expression.
         *
         *  The result of this is that for something like `((x > 0) ? a : b).x = 5`, the heap ends up
         *  like so:
         *      `a = { x: (x > 0) ? 5 : 3 }`
         *      `b = { x: (x > 0) ? 2 : 5 }`
         *  which is exactly as desired.
         */

        val heapKeysInvolved =
            qualifier.iterateTree()
                .filterIsInstance<ClassExpression>()
                .map { it.heapKey }
                .toSet()

        val newHeap = heap.mapValues { (heapKey, obj) ->
            if (heapKey !in heapKeysInvolved) {
                // Don't touch objects on the heap that are not involved in this assignment.
                obj
            } else {
                val newValue = qualifier.replaceTypeInLeaves<ClassExpression>(fieldKey.ind) { expr ->
                    if (expr.heapKey == heapKey) {
                        rExpr
                    } else {
                        obj[fieldKey] ?: throw IllegalArgumentException(
                            "Qualifier for $fieldKey not found in context"
                        )
                    }
                }

                obj + (fieldKey to newValue)
            }
        }

        return Context(
            variables = variables,
            heap = newHeap,
            thisObj = thisObj
        )

    }

    /**
     * This should only be used externally in special circumstances â€” most of the time
     * you should be using `withVar(lExpr, rExpr)` instead.
     *
     * This will be useful sometimes, though, e.g. setting up return values, declarations, or parameters.
     */
    fun withVar(key: Key, expr: Expr<*>): Context {
        val castVar = expr.castToUsingTypeCast(key.ind, false)
        return Context(variables + (key to castVar), heap, thisObj)
    }

    /**
     * Performs a cast if necessary.
     */
    fun withResolvedVar(key: Key, expr: Expr<*>): Context {
        val castExpr = expr.castToUsingTypeCast(key.ind, false)

        return Context(variables.mapValues { (_, oldExpr) ->
            oldExpr.replaceTypeInTree<VariableExpression<*>> {
                if (it.key == key) castExpr else null
            }
        }, heap, thisObj)
    }
}