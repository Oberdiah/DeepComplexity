package com.github.oberdiah.deepcomplexity.evaluation

import com.github.oberdiah.deepcomplexity.evaluation.Context.Key
import com.github.oberdiah.deepcomplexity.evaluation.Context.Key.EphemeralKey
import com.github.oberdiah.deepcomplexity.evaluation.Context.Key.QualifiedKey
import com.github.oberdiah.deepcomplexity.staticAnalysis.DoubleSetIndicator
import com.github.oberdiah.deepcomplexity.staticAnalysis.SetIndicator
import com.github.oberdiah.deepcomplexity.staticAnalysis.constrainedSets.Bundle
import com.github.oberdiah.deepcomplexity.utilities.Utilities
import com.github.oberdiah.deepcomplexity.utilities.Utilities.toStringPretty
import com.intellij.psi.*

typealias Vars = Map<Key, Expr<*>>

class Context private constructor(
    val variables: Vars,
) {
    init {
        assert(variables.keys.none { it is EphemeralKey }) {
            "Ephemeral keys shouldn't be used as variable keys."
        }
    }

    /**
     * This isn't a full key by itself, you'll need a [HeapRef] as well and then will want to make a [QualifiedKey].
     */
    data class FieldRef(private val variable: PsiField) {
        override fun toString(): String = variable.toStringPretty()
        fun getElement(): PsiElement = variable
        val ind: SetIndicator<*> = Utilities.psiTypeToSetIndicator(variable.type)
    }

    data class HeapRef(
        private val idx: Int,
        val brandNew: Boolean
    ) {
        companion object {
            private var KEY_INDEX = 0
            val This = new(false)
            fun new(brandNew: Boolean = true): HeapRef = HeapRef(KEY_INDEX++, brandNew)
        }

        fun isThis(): Boolean = this == This
        override fun equals(other: Any?): Boolean = other is HeapRef && this.idx == other.idx
        override fun hashCode(): Int = idx.hashCode()
        override fun toString(): String = if (this == This) "this" else "#${idx}"
    }

    sealed class Key {
        abstract class VariableKey() : Key() {
            abstract val variable: PsiVariable
        }

        data class LocalVariableKey(override val variable: PsiLocalVariable) : VariableKey() {
            override fun toString(): String = variable.toStringPretty()
        }

        data class ParameterKey(override val variable: PsiParameter) : VariableKey() {
            override fun toString(): String = variable.toStringPretty()
        }

        data class QualifiedKey(val field: FieldRef, val qualifier: HeapRef = HeapRef.This) : Key() {
            override fun toString(): String = "$qualifier.$field"
        }

        data class ReturnKey(val type: SetIndicator<*>) : Key() {
            companion object {
                val Me = ReturnKey(DoubleSetIndicator)
            }

            override fun toString(): String = "Return value"
            override fun hashCode(): Int = 0
            override fun equals(other: Any?): Boolean = other is ReturnKey
        }

        /**
         * Used to allow us to equate expressions.
         */
        data class ExpressionKey(val expr: Expr<*>) : Key() {
            override fun toString(): String = ExprToString.toExprKeyString(expr)
        }

        /**
         * Primarily for testing, doesn't have a specific element.
         */
        data class EphemeralKey(val key: Any) : Key() {
            override fun toString(): String = "#$key"

            companion object {
                private var KEY_INDEX = 0
                fun new(): EphemeralKey {
                    return EphemeralKey(KEY_INDEX++)
                }
            }
        }

        open val ind: SetIndicator<*>
            get() {
                return when (this) {
                    is ExpressionKey -> this.expr.ind
                    is ReturnKey -> type
                    is VariableKey -> Utilities.psiTypeToSetIndicator(variable.type)
                    is QualifiedKey -> this.field.ind
                    else -> throw IllegalArgumentException("Cannot get indicator for $this")
                }
            }

        fun isAutogenerated(): Boolean = isEphemeral() || isExpr()
        fun isEphemeral(): Boolean = this is EphemeralKey
        fun isExpr(): Boolean = this is ExpressionKey

        /**
         * When multiplying, we need to decide which one gets to live on.
         */
        fun importance(): Int {
            return when (this) {
                is VariableKey -> 5
                is QualifiedKey -> 4
                is ReturnKey -> 2
                is ExpressionKey -> 1
                is EphemeralKey -> 0
            }
        }

        /**
         * If the key is a variable (i.e. a Local Variable, Field, etc.), returns the variable.
         * If the key is a return statement, returns the method we're returning from.
         */
        fun getElement(): PsiElement {
            return when (this) {
                is VariableKey -> variable
                is QualifiedKey -> field.getElement()
                is ReturnKey -> throw IllegalArgumentException("Cannot get element of return key")
                is EphemeralKey -> throw IllegalArgumentException("Cannot get element of arbitrary key")
                is ExpressionKey -> throw IllegalArgumentException("Cannot get element of expression key")
            }
        }

        fun matchesElement(element: PsiElement): Boolean {
            return getElement() == element
        }
    }

    companion object {
        /**
         * You won't want this often, in nearly all cases it makes sense
         * to inherit the existing context via cloning.
         */
        fun brandNew(): Context = Context(emptyMap())

        /**
         * Combines two contexts at the same 'point in time' e.g. a branching if statement.
         * This does not and cannot resolve any unresolved expressions as these two statements
         * are independent of each other.
         *
         * You must define how to resolve conflicts.
         */
        fun combine(a: Context, b: Context, how: (a: Expr<*>, b: Expr<*>) -> Expr<*>): Context {
            return Context(
                (a.variables.keys + b.variables.keys)
                    .associateWith { key ->
                        /**
                         * An annoying blot on an otherwise fairly nice function.
                         * We need to know whether the object has been created within this context or not.
                         * In theory, not doing this is not technically wrong, but it results in unresolved
                         * expressions sitting around and generally being a nuisance.
                         *
                         * To give an example,
                         * ```
                         * var a = new C(2);
                         * if (x > 0) {
                         *     a = new C(3);
                         * }
                         * ```
                         * If we didn't do this then when resolving the if statement you'd get `#2.x = (x > 0) ? 3 : #2.x`,
                         * as `#2.x` would have never been seen before. With this check, we know for certain
                         * that `#2` is a brand-new object, so we can safely resolve it to `#2.x = 3`.
                         */
                        if (key is QualifiedKey && key.qualifier.brandNew) {
                            val aVal = a.variables[key]
                            val bVal = b.variables[key]

                            assert(aVal == null || bVal == null) {
                                "Something's suspicious, it's likely the `brandNew` tracking is off. " +
                                        "This should be unable to happen, as a brand new object should have a unique key."
                            }

                            aVal ?: bVal!!
                        } else {
                            val aVal = a.getVar(key)
                            val bVal = b.getVar(key)
                            // This equality is probably not very cheap.
                            // I'm sure that can be improved in the future.
                            if (aVal == bVal) {
                                aVal
                            } else {
                                how(aVal, bVal)
                            }
                        }
                    }
            )
        }
    }

    val returnValue: Expr<*>?
        get() = variables[Key.ReturnKey.Me]

    override fun toString(): String {
        val variablesString =
            variables.entries.joinToString("\n") { entry ->
                val expr = entry.value
                val key = entry.key

                "$key:\n${expr.toString().prependIndent()}"
            }
        return "Context: {\n${variablesString.prependIndent()}\n}"
    }

    fun clone(): Context = Context(
        variables.mapKeys {
            val key = it.key
            if (key is QualifiedKey) {
                key.copy(qualifier = key.qualifier.copy(brandNew = false))
            } else {
                key
            }
        })

    fun debugKey(key: Key): String {
        return variables[key]?.dStr() ?: "Key not found"
    }

    fun canResolve(variable: VariableExpression<*>): Boolean {
        return variables.containsKey(variable.key)
    }

    fun evaluateKey(key: Key): Bundle<*> {
        val expr = variables[key] ?: throw IllegalArgumentException("Key $key not found in context")
        return expr.evaluate(ExprEvaluate.Scope())
    }

    fun getVar(element: Key): Expr<*> {
        return variables[element] ?: VariableExpression<Any>(element)
    }

    fun withVar(lExpr: LValueExpr<*>, rExpr: Expr<*>): Context {
        assert(rExpr.iterateTree().none { it is LValueExpr }) {
            "Cannot assign an LValueExpr to a variable: $lExpr = $rExpr. Try using `.resolveLValues(context)` on it first."
        }

        if (lExpr is LValueKeyExpr) {
            val castVar = rExpr.castToUsingTypeCast(lExpr.key.ind, false)
            return Context(variables + (lExpr.key to castVar))
        } else if (lExpr !is LValueFieldExpr) {
            throw IllegalArgumentException("This cannot happen")
        }

        /**
         * This does look a bit scary, so I'll try to walk you through it:
         * Essentially, a qualifier may not just be a simple VariableExpression with a HeapKey.
         * In the simplest case it is, and this all becomes a lot easier, but in the general case
         * it may be any complicated expression.
         * Let's go with the following example:
         * ```
         * a = new C(2);
         * b = new C(3);
         * ((x > 0) ? a : b).x = 5
         * ```
         * Now, the only objects we should be touching with our operation are `a` and `b`, so we gather
         * them first into [varKeysInvolved]. That part's simple enough.
         *
         * Then, for the variables we want to modify, we take our qualifier as specified above, and replace
         * `a` and `b` with either:
         *      a) The value already at that object, effectively turning `b` into `b.x`
         *      b) The value that we're setting this field to
         *  depending on whether the object we're modifying is the object being replaced in the expression.
         *
         *  The result of this is that for something like `((x > 0) ? a : b).x = 5`, the variables end up
         *  like so:
         *      `a.x = { (x > 0) ? 5 : 3 }`
         *      `b.x = { (x > 0) ? 2 : 5 }`
         *  which is exactly as desired.
         */

        val qualifier = lExpr.qualifier
        val fieldKey = lExpr.field

        val objectsMentionedInQualifier =
            qualifier.iterateTree()
                .filterIsInstance<ObjectExpression>()
                .map { it.key }
                .toSet()

        val newVariables = variables + objectsMentionedInQualifier.map {
            val thisVarKey = QualifiedKey(fieldKey, it)
            val newValue = qualifier.replaceTypeInLeaves<ObjectExpression>(fieldKey.ind) { expr ->
                if (expr.key == it) {
                    rExpr
                } else {
                    getVar(thisVarKey)
                }
            }

            (thisVarKey to newValue)
        }

        return Context(newVariables)
    }

    /**
     * Performs a cast if necessary.
     */
    fun withResolvedVar(key: Key, expr: Expr<*>): Context {
        val castExpr = expr.castToUsingTypeCast(key.ind, false)

        return Context(variables.mapValues { (_, oldExpr) ->
            oldExpr.replaceTypeInTree<VariableExpression<*>> {
                if (it.key == key) castExpr else null
            }
        })
    }

    /**
     * Resolves all variables in the expression that are known of in this context.
     */
    fun resolveKnownVariables(expr: Expr<*>): Expr<*> =
        expr.replaceTypeInTree<VariableExpression<*>> { variables[it.key] }

    /**
     * Qualify all fields without existing paths in the expression with `thisObj`, effectively
     * defining a 'this' for them.
     */
    fun resolveThis(thisObj: Expr<*>?): Context {
        if (thisObj == null) {
            // If we don't have a 'this' object, we can't resolve anything.
            return this
        }

        var newContext = brandNew()

        // All we're doing here is replacing all instances of `this` with the passed in object.
        // The complexity comes from the fact `this` could be in three different places:
        //     1. As a qualifier in a [QualifiedKey], e.g. `this.x = 5`
        //     2. Literally as an [ObjectExpression], e.g. `a = this`
        //     3. As a key in a [VariableExpression], e.g. `a = this.x`
        for ((key, expr) in variables) {
            val lValue = if (key is QualifiedKey && key.qualifier.isThis()) {
                LValueFieldExpr<Any>(key.field, thisObj)
            } else {
                // Do nothing, just assign as normal.
                LValueKeyExpr(key)
            }

            val rValue = expr.replaceTypeInTree<VariableExpression<*>> { varExpr ->
                if (varExpr.key is QualifiedKey && varExpr.key.qualifier.isThis()) {
                    thisObj.getField(newContext, varExpr.key.field)
                } else {
                    null
                }
            }.replaceTypeInTree<ObjectExpression> { objExpr ->
                if (objExpr.key.isThis()) thisObj else null
            }

            newContext = newContext.withVar(lValue, rValue)
        }

        return newContext
    }

    /**
     * Stacks the later context on top of this one.
     *
     * That is, prioritise the later context and fall back to this one if the key doesn't exist.
     *
     * Conversely, for `Method` keys, this context is prioritised over the later context.
     */
    fun stack(later: Context): Context {
        val laterResolvedWithMe = later.variables.mapValues { (_, expr) -> resolveKnownVariables(expr) }
        val meResolvedWithLater = variables.mapValues { (_, expr) -> later.resolveKnownVariables(expr) }

        val newVariables = mutableMapOf<Key, Expr<*>>()
        // For normal keys, later takes priority and gets to override.
        newVariables.putAll(meResolvedWithLater.filter { it.key !is Key.ReturnKey })
        newVariables.putAll(laterResolvedWithMe.filter { it.key !is Key.ReturnKey })

        // For method keys, this context takes priority.
        newVariables.putAll(laterResolvedWithMe.filter { it.key is Key.ReturnKey })
        newVariables.putAll(meResolvedWithLater.filter { it.key is Key.ReturnKey })

        return Context(newVariables)
    }

    fun withoutReturns(): Context {
        // This is a convenience method to drop all return values from the context.
        return Context(variables.filterKeys { it !is Key.ReturnKey })
    }
}