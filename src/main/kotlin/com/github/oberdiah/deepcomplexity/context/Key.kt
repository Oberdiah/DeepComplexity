package com.github.oberdiah.deepcomplexity.context

import com.github.oberdiah.deepcomplexity.evaluation.Expr
import com.github.oberdiah.deepcomplexity.evaluation.ExprToString
import com.github.oberdiah.deepcomplexity.staticAnalysis.SetIndicator
import com.intellij.psi.PsiElement

/**
 * If [temporary] is true this key will be removed from the context
 * after stacking. This is useful for tidying up keys that are only
 * added to aid resolution, such as parameters and `this`.
 */
sealed class Key() {
    abstract val ind: SetIndicator<*>

    /**
     * Used to allow us to equate expressions.
     */
    data class ExpressionKey(val expr: Expr<*>) : Key() {
        override val ind: SetIndicator<*>
            get() = expr.ind

        override fun toString(): String = ExprToString.toExprKeyString(expr)
    }

    /**
     * Purely used to represent the constant value in a NumberVariance
     */
    object ConstantKey : Key() {
        override val ind: SetIndicator<*>
            get() = throw IllegalStateException("Constant keys don't have a type.")

        override fun toString(): String = "C"
    }

    fun isAutogenerated(): Boolean = isConstant() || isExpr()
    fun isConstant(): Boolean = this is ConstantKey
    fun isExpr(): Boolean = this is ExpressionKey

    /**
     * When multiplying, we need to decide which one gets to live on.
     */
    fun importance(): Int {
        return when (this) {
            is VariableKey -> 6
            is QualifiedFieldKey -> 5
            is ThisKey -> 4
            is ReturnKey -> 2
            is ExpressionKey -> 1
            is ConstantKey -> 0
            is PlaceholderKey -> 0
        }
    }

    /**
     * If the key is a variable (i.e. a Local Variable, Field, etc.), returns the variable.
     * If the key is a return statement, returns the method we're returning from.
     */
    fun getElement(): PsiElement {
        return when (this) {
            is VariableKey -> variable
            is QualifiedFieldKey -> field.getElement()
            is ThisKey -> throw IllegalArgumentException("Cannot get element of this key")
            is PlaceholderKey -> throw IllegalArgumentException("Cannot get element of placeholder key")
            is ReturnKey -> throw IllegalArgumentException("Cannot get element of return key")
            is ConstantKey -> throw IllegalArgumentException("Cannot get element of arbitrary key")
            is ExpressionKey -> throw IllegalArgumentException("Cannot get element of expression key")
        }
    }

    fun matchesElement(element: PsiElement): Boolean {
        return getElement() == element
    }
}