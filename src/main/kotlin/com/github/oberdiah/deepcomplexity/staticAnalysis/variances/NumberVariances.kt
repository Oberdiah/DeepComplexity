package com.github.oberdiah.deepcomplexity.staticAnalysis.variances

import com.github.oberdiah.deepcomplexity.evaluation.BinaryNumberOp
import com.github.oberdiah.deepcomplexity.evaluation.BinaryNumberOp.*
import com.github.oberdiah.deepcomplexity.evaluation.ComparisonOp
import com.github.oberdiah.deepcomplexity.evaluation.Context
import com.github.oberdiah.deepcomplexity.evaluation.ExprEvaluate
import com.github.oberdiah.deepcomplexity.solver.ConstraintSolver
import com.github.oberdiah.deepcomplexity.staticAnalysis.NumberSetIndicator
import com.github.oberdiah.deepcomplexity.staticAnalysis.SetIndicator
import com.github.oberdiah.deepcomplexity.staticAnalysis.constrainedSets.Constraints
import com.github.oberdiah.deepcomplexity.staticAnalysis.sets.BooleanSet
import com.github.oberdiah.deepcomplexity.staticAnalysis.sets.NumberSet
import com.github.oberdiah.deepcomplexity.staticAnalysis.sets.into
import com.github.oberdiah.deepcomplexity.utilities.Functional
import com.jetbrains.rd.util.first

@ConsistentCopyVisibility
data class NumberVariances<T : Number> private constructor(
    override val ind: NumberSetIndicator<T>,
    private val multipliers: Map<Context.Key, NumberSet<T>> = mapOf()
) : Variances<T> {
    init {
        assert(multipliers.keys.count { it.isEphemeral() } <= 1) {
            "Only one ephemeral key is allowed in the variances map"
        }
    }

    /**
     * They're equal if everything matches except the ephemeral key, which can be different.
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is NumberVariances<*>) return false
        if (ind != other.ind) return false
        val myNonEphemeralMultipliers = multipliers.filterKeys { !it.isEphemeral() }
        val otherNonEphemeralMultipliers = other.multipliers.filterKeys { !it.isEphemeral() }
        if (myNonEphemeralMultipliers != otherNonEphemeralMultipliers) return false
        val myEphemeralMultiplier = multipliers.filterKeys { it.isEphemeral() }.first().value
        val otherEphemeralMultiplier = other.multipliers.filterKeys { it.isEphemeral() }.first().value
        return myEphemeralMultiplier == otherEphemeralMultiplier
    }

    override fun hashCode(): Int {
        var result = ind.hashCode()
        val myNonEphemeralMultipliers = multipliers.filterKeys { !it.isEphemeral() }
        result = 31 * result + myNonEphemeralMultipliers.hashCode()
        val myEphemeralMultiplier = multipliers.filterKeys { it.isEphemeral() }.first().value
        result = 31 * result + myEphemeralMultiplier.hashCode()
        return result
    }

    override fun toString(): String {
        return multipliers.entries.joinToString(", ") { (key, multiplier) ->
            "$key: ($multiplier)"
        }
    }

    companion object {
        fun <T : Number> newFromConstant(constant: NumberSet<T>): NumberVariances<T> =
            newFromMultiplierMap(constant.ind, mapOf(Context.Key.EphemeralKey.new() to constant))

        fun <T : Number> newFromVariance(ind: NumberSetIndicator<T>, key: Context.Key): NumberVariances<T> {
            return newFromMultiplierMap(ind, mapOf(key to ind.onlyOneSet()))
        }

        private fun <T : Number> newFromMultiplierMap(
            ind: NumberSetIndicator<T>,
            multipliers: Map<Context.Key, NumberSet<T>>
        ): NumberVariances<T> {
            val ephemeralMap = multipliers.filterKeys { it.isEphemeral() }
            val notEphemeralMap = multipliers.filterKeys { !it.isEphemeral() }

            // Ensure only one ephemeral key is present.
            // If more than one is present, we need to merge them through addition.
            // I think proving division with this might be really hard.
            val ephemeralMultiplier =
                ephemeralMap.values.fold(ind.onlyZeroSet()) { acc, multiplier ->
                    acc.add(multiplier)
                }

            return NumberVariances(
                ind,
                notEphemeralMap + (Context.Key.EphemeralKey.new() to ephemeralMultiplier)
            )
        }
    }

    override fun toDebugString(constraints: Constraints): String {
        return if (varsTracking().isEmpty()) {
            collapse(constraints).toString()
        } else {
            multipliers.entries.filter { (k, m) -> !(m.isZero() && k.isAutogenerated()) }
                .joinToString(" + ") { (key, multiplier) ->
                    val multiplierStr = if (multiplier.isOne() && !key.isEphemeral()) "" else "$multiplier"
                    val keyStr = if (key.isEphemeral()) "" else key.toString()
                    val constraint = constraints.getConstraint(ind, key)
                    val constraintStr = if (constraint.isFull()) "" else "[$constraint]"

                    "$multiplierStr$keyStr$constraintStr"
                }
        }
    }

    override fun varsTracking(): Collection<Context.Key> {
        return multipliers.keys.filter { !it.isEphemeral() }
    }

    override fun reduceAndSimplify(scope: ExprEvaluate.Scope, constraints: Constraints): Variances<T> {
        return newFromMultiplierMap(
            ind,
            multipliers.entries.associate { (key, v) ->
                if (scope.shouldKeep(key)) {
                    key to v
                } else {
                    Context.Key.EphemeralKey.new() to v.multiply(grabConstraint(constraints, key))
                }
            }
        )
    }

    fun grabConstraint(constraints: Constraints, key: Context.Key): NumberSet<T> {
        return if (key.isEphemeral()) {
            // Constants/ephemeral keys don't have any variance or constraints,
            // so the 'variable', if you can call it that, is always constrained to exactly 1.
            ind.onlyOneSet()
        } else {
            constraints.getConstraint(ind, key).into()
        }
    }

    /**
     * Collapse the multipliers into a single set of values.
     * Requires constraints because a NumberVariance on its own doesn't contain
     * all the information it needs alone.
     */
    override fun collapse(constraints: Constraints): NumberSet<T> =
        multipliers.entries.fold(ind.onlyZeroSet()) { acc, (key, multiplier) ->
            acc.add(multiplier.multiply(grabConstraint(constraints, key)))
        }

    override fun <Q : Any> cast(newInd: SetIndicator<Q>): Variances<Q>? {
        if (newInd !is NumberSetIndicator<*>) {
            return null
        }

        fun <OutT : Number> extra(newInd: NumberSetIndicator<OutT>): NumberVariances<OutT>? {
            return newFromMultiplierMap(newInd, multipliers.mapValues { (_, multiplier) ->
                // I have no idea if doing this actually works with wrapping. Probably doesn't.
                // Worth writing a test for it at some point.
                multiplier.cast(newInd)?.into() ?: return null
            })
        }

        @Suppress("UNCHECKED_CAST") // Safety: Trivially true by checking the signature of extra().
        return extra(newInd) as Variances<Q>?
    }

    fun isOne(constraints: Constraints): Boolean = collapse(constraints).isOne()

    fun negate(): NumberVariances<T> {
        return newFromMultiplierMap(ind, multipliers.mapValues { (_, multiplier) ->
            multiplier.negate()
        })
    }

    fun arithmeticOperation(
        other: NumberVariances<T>,
        operation: BinaryNumberOp,
        constraints: Constraints
    ): NumberVariances<T> {
        when (operation) {
            ADDITION, SUBTRACTION -> {
                return newFromMultiplierMap(
                    ind, Functional.mergeMapsWithBlank(
                        multipliers,
                        other.multipliers,
                        ind.onlyZeroSet()
                    ) { me, other ->
                        if (operation == ADDITION) {
                            me.add(other)
                        } else {
                            me.subtract(other)
                        }
                    })
            }

            MULTIPLICATION -> {
                val newMultipliers = mutableMapOf<Context.Key, NumberSet<T>>()

                for ((key, meMultiplier) in multipliers) {
                    for ((otherKey, otherMultiplier) in other.multipliers) {
                        val meCollapsed = meMultiplier.multiply(grabConstraint(constraints, key))
                        val otherCollapsed = otherMultiplier.multiply(grabConstraint(constraints, otherKey))

                        val myImportance = key.importance()
                        val otherImportance = otherKey.importance()

                        val baseMultiplier = if (myImportance >= otherImportance) {
                            meMultiplier.multiply(otherCollapsed)
                        } else {
                            otherMultiplier.multiply(meCollapsed)
                        }

                        val newMultiplier = if (key == otherKey) {
                            baseMultiplier.intersect(ind.positiveNumbersAndZero())
                        } else {
                            baseMultiplier
                        }

                        val baseKey = if (myImportance >= otherImportance) key else otherKey

                        newMultipliers.compute(baseKey) { _, set ->
                            set?.add(newMultiplier) ?: newMultiplier
                        }
                    }
                }

                return newFromMultiplierMap(ind, newMultipliers)
            }

            DIVISION -> {
                if (other.isOne(constraints)) {
                    return this
                }

                // Division is going to be really hard to get right due to order-of-operations.
                TODO("DIVISION :(")
            }

            MODULO -> {
                val meCollapsed = this.collapse(constraints)
                val otherCollapsed = other.collapse(constraints)

                return newFromConstant(
                    meCollapsed.arithmeticOperation(otherCollapsed, MODULO)
                )
            }
        }
    }

    fun comparisonOperation(
        other: NumberVariances<T>,
        operation: ComparisonOp,
        constraints: Constraints
    ): BooleanVariances =
        // We could maybe do something smarter here long-term, but this'll do for now.
        collapse(constraints).comparisonOperation(other.collapse(constraints), operation).toConstVariance().into()

    fun generateConstraintsFrom(
        other: NumberVariances<T>,
        comp: ComparisonOp,
        incomingConstraints: Constraints
    ): Constraints {
        val allKeys = (multipliers.keys + other.multipliers.keys).filter { !it.isEphemeral() }

        var constraints = Constraints.completelyUnconstrained()

        for (key in allKeys) {
            val myKeyMultiplier = multipliers[key] ?: ind.onlyZeroSet()
            val otherKeyMultiplier = other.multipliers[key] ?: ind.onlyZeroSet()

            fun <T : Number> extra(keyInd: NumberSetIndicator<T>) {
                // Move all the keys onto the left
                val coefficient = myKeyMultiplier.subtract(otherKeyMultiplier)
                    .cast(keyInd)!!.into()

                val lhsConstant =
                    newFromMultiplierMap(ind, multipliers.filter { it.key != key })
                        .collapse(incomingConstraints)
                        .cast(keyInd)!!.into()
                val rhsConstant =
                    newFromMultiplierMap(ind, other.multipliers.filter { it.key != key })
                        .collapse(incomingConstraints)
                        .cast(keyInd)!!.into()

                val constant = rhsConstant.subtract(lhsConstant)

                if (coefficient.isZero()) {
                    // The key has cancelled itself out, this is now an all-or-nothing situation:
                    // either the constraint is met, or it isn't.
                    // The equation at this point looks like `0x blah constant`
                    // So we can just check the constant against zero.
                    val meetsConstraint = keyInd.onlyZeroSet().comparisonOperation(constant, comp)
                    constraints = when (meetsConstraint) {
                        BooleanSet.BOTH, BooleanSet.TRUE -> constraints.withConstraint(key, keyInd.newFullSet())
                        BooleanSet.FALSE, BooleanSet.NEITHER -> constraints.withConstraint(key, keyInd.newEmptySet())
                    }
                } else {
                    val shouldFlip = coefficient.comparisonOperation(keyInd.onlyZeroSet(), ComparisonOp.LESS_THAN)
                    val rhs = constant.divide(coefficient)
                    val constraint = when (shouldFlip) {
                        BooleanSet.TRUE -> rhs.getSetSatisfying(comp.flip())
                        BooleanSet.FALSE -> rhs.getSetSatisfying(comp)
                        BooleanSet.BOTH -> rhs.getSetSatisfying(comp)
                            .union(rhs.getSetSatisfying(comp.flip()))

                        BooleanSet.NEITHER -> throw IllegalStateException("Condition is neither true nor false!")
                    }

                    constraints = constraints.withConstraint(key, constraint)
                }
            }

            extra(key.ind as NumberSetIndicator<*>)
        }

        return constraints
    }

    fun evaluateLoopingRange(
        changeTerms: ConstraintSolver.CollectedTerms<T>,
        valid: NumberSet<T>
    ): NumberVariances<T> = TODO("Not yet implemented")
}