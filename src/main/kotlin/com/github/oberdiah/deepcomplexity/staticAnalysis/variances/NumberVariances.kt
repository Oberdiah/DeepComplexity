package com.github.oberdiah.deepcomplexity.staticAnalysis.variances

import com.github.oberdiah.deepcomplexity.evaluation.BinaryNumberOp
import com.github.oberdiah.deepcomplexity.evaluation.BinaryNumberOp.*
import com.github.oberdiah.deepcomplexity.evaluation.ComparisonOp
import com.github.oberdiah.deepcomplexity.evaluation.Context
import com.github.oberdiah.deepcomplexity.evaluation.ExprEvaluate
import com.github.oberdiah.deepcomplexity.solver.ConstraintSolver
import com.github.oberdiah.deepcomplexity.staticAnalysis.NumberSetIndicator
import com.github.oberdiah.deepcomplexity.staticAnalysis.SetIndicator
import com.github.oberdiah.deepcomplexity.staticAnalysis.constrainedSets.Constraints
import com.github.oberdiah.deepcomplexity.staticAnalysis.sets.BooleanSet
import com.github.oberdiah.deepcomplexity.staticAnalysis.sets.NumberSet
import com.github.oberdiah.deepcomplexity.staticAnalysis.sets.into
import com.github.oberdiah.deepcomplexity.utilities.Functional
import com.jetbrains.rd.util.firstOrNull

// Ok, here's the new thinking:
// This is a really difficult problem, and it's not possible to do it 100% correctly, but we're going to
// try as best we can, because there's a lot to gain from getting most of the way there.
// The idea is that we're going to go back to variances storing their own version of constraints internally.
// To begin with we'll keep all the constraints being passed in, we'll just also keep track of them inside
// and update our internal representation as we go along.
// Using that, we're going to make best-guesses at how to perform each of these operations on this strange
// data structure.
// The important part is we're going to start verifying that the result, when collapsed, is the same as
// the result of the operation done on the collapsed version instead.
// We can specify that as an invariant when getting started.
// That way we can quickly catch mistakes that we make along the way.
// This doesn't solve the problem of generating the constraints themselves, which I think may still be quite
// hard to do correctly, but at the very least it sorts most of the stuff out.
// Long term for that I want to store constraints as variances.

@ConsistentCopyVisibility
data class NumberVariances<T : Number> private constructor(
    override val ind: NumberSetIndicator<T>,
    private val variances: Map<Context.Key, Variance<T>> = mapOf()
) : Variances<T> {
    class Variance<T : Number>(
        private val ind: NumberSetIndicator<T>,
        /**
         * The value that the underlying variable is being multiplied by.
         * This should always be 1 for ephemeral keys.
         */
        val multiplier: NumberSet<T> = ind.onlyOneSet(),
        /**
         * Whatever the underlying variable is known to be constrained within.
         * This can be tighter than constraints passed in, for example, after a casting operation.
         */
        val restrictor: NumberSet<T> = ind.newFullSet()
    ) {
        fun collapse(): NumberSet<T> = multiplier.multiply(restrictor)
        override fun toString(): String {
            return if (restrictor.isFull() || restrictor.isZero()) {
                "$multiplier"
            } else {
                "$multiplier[$restrictor]"
            }
        }
    }

    init {
        assert(variances.keys.count { it.isEphemeral() } <= 1) {
            "Only one ephemeral key is allowed in the variances map"
        }
    }

    /**
     * They're equal if everything matches except the ephemeral key, which can be different.
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is NumberVariances<*>) return false
        if (ind != other.ind) return false
        val myNonEphemeralMultipliers = variances.filterKeys { !it.isEphemeral() }
        val otherNonEphemeralMultipliers = other.variances.filterKeys { !it.isEphemeral() }
        if (myNonEphemeralMultipliers != otherNonEphemeralMultipliers) return false
        val myEphemeralMultiplier = variances.filterKeys { it.isEphemeral() }.firstOrNull()?.value
        val otherEphemeralMultiplier = other.variances.filterKeys { it.isEphemeral() }.firstOrNull()?.value
        return myEphemeralMultiplier == otherEphemeralMultiplier
    }

    override fun hashCode(): Int {
        var result = ind.hashCode()
        val myNonEphemeralMultipliers = variances.filterKeys { !it.isEphemeral() }
        result = 31 * result + myNonEphemeralMultipliers.hashCode()
        val myEphemeralMultiplier = variances.filterKeys { it.isEphemeral() }.firstOrNull()?.value
        result = 31 * result + myEphemeralMultiplier.hashCode()
        return result
    }

    override fun toString(): String {
        return if (varsTracking().isEmpty()) {
            collapse().toString()
        } else {
            variances.entries
                .filter { (k, m) -> !(m.restrictor.isZero() && k.isAutogenerated()) }
                .joinToString(" + ") { (key, variance) ->
                    val multiplierStr =
                        if (variance.multiplier.isOne() && !key.isEphemeral()) "" else "${variance.multiplier}"
                    val keyStr = if (key.isEphemeral()) "" else key.toString()
                    val constraint = variance.restrictor
                    val constraintStr = if (constraint.isFull()) "" else "[$constraint]"

                    "$multiplierStr$keyStr$constraintStr"
                }
        }
    }

    companion object {
        fun <T : Number> newFromConstant(constant: NumberSet<T>): NumberVariances<T> =
            newFromVariances(
                constant.ind,
                mapOf(Context.Key.EphemeralKey.new() to Variance(constant.ind, restrictor = constant))
            )

        fun <T : Number> newFromVariance(ind: NumberSetIndicator<T>, key: Context.Key): NumberVariances<T> {
            return newFromVariances(ind, mapOf(key to Variance(ind)))
        }

        private fun <T : Number> newFromVariances(
            ind: NumberSetIndicator<T>,
            variances: Map<Context.Key, Variance<T>>
        ): NumberVariances<T> {
            val ephemeralMap = variances.filterKeys { it.isEphemeral() }
            val notEphemeralMap = variances.filterKeys { !it.isEphemeral() }

            // Ensure only one ephemeral key is present.
            // If more than one is present, we need to merge them through addition.
            // I think proving division with this might be really hard.
            val ephemeralRestrictor =
                ephemeralMap.values.fold(ind.onlyZeroSet()) { acc, variance ->
                    acc.add(variance.collapse())
                }

            val finalMap = if (!ephemeralRestrictor.isEmpty()) {
                notEphemeralMap + (Context.Key.EphemeralKey.new() to Variance(ind, restrictor = ephemeralRestrictor))
            } else {
                notEphemeralMap
            }

            return NumberVariances(ind, finalMap)
        }
    }

    override fun updateConstraints(constraints: Constraints): Variances<T> {
        return newFromVariances(ind, variances.mapValues { (key, variance) ->
            Variance(
                ind,
                variance.multiplier,
                variance.restrictor.intersect(constraints.getConstraint(ind, key).into())
            )
        })
    }

    override fun toDebugString(): String = toString()

    override fun varsTracking(): Collection<Context.Key> {
        return variances.keys.filter { !it.isEphemeral() }
    }

    override fun reduceAndSimplify(scope: ExprEvaluate.Scope): Variances<T> {
        return newFromVariances(
            ind,
            variances.entries.associate { (key, variance) ->
                if (scope.shouldKeep(key)) {
                    key to variance
                } else {
                    Context.Key.EphemeralKey.new() to Variance(
                        ind,
                        restrictor = variance.collapse()
                    )
                }
            }
        )
    }

    /**
     * Collapse the multipliers into a single set of values.
     * Requires constraints because a NumberVariance on its own doesn't contain
     * all the information it needs alone.
     */
    override fun collapse(): NumberSet<T> {
        val result = variances.entries.fold(ind.onlyZeroSet()) { acc, (_, variance) ->
            acc.add(variance.collapse())
        }
        return result
    }

    override fun <Q : Any> cast(newInd: SetIndicator<Q>): Variances<Q>? {
        if (newInd !is NumberSetIndicator<*>) {
            return null
        }

        fun <OutT : Number> extra(newInd: NumberSetIndicator<OutT>): NumberVariances<OutT>? {
            return newFromVariances(newInd, variances.mapValues { (_, variance) ->
                Variance(
                    newInd,
                    multiplier = variance.multiplier.cast(newInd)?.into() ?: return null,
                    restrictor = variance.restrictor.cast(newInd)?.into() ?: return null
                )
            })
        }

        @Suppress("UNCHECKED_CAST") // Safety: Trivially true by checking the signature of extra().
        return extra(newInd) as Variances<Q>?
    }

    fun isOne(): Boolean = collapse().isOne()

    fun negate(): NumberVariances<T> {
        return newFromVariances(ind, variances.mapValues { (_, variances) ->
            Variance(
                ind,
                multiplier = variances.multiplier.negate(),
                restrictor = variances.restrictor
            )
        })
    }

    fun arithmeticOperation(
        other: NumberVariances<T>,
        operation: BinaryNumberOp
    ): NumberVariances<T> {
        when (operation) {
            ADDITION, SUBTRACTION -> {
                val me = variances
                val other = other.variances

                val result = newFromVariances(
                    ind, Functional.mergeMapsWithBlank(
                        me,
                        other,
                        Variance(ind, multiplier = ind.onlyZeroSet())
                    ) { me, other ->
                        val v = Variance(
                            ind,
                            multiplier = if (operation == ADDITION) {
                                me.multiplier.add(other.multiplier)
                            } else {
                                me.multiplier.subtract(other.multiplier)
                            },
                            restrictor = me.restrictor.intersect(other.restrictor)
                        )
                        v
                    })

                return result
            }

            MULTIPLICATION -> {
                val newVariances = mutableMapOf<Context.Key, Variance<T>>()

                for ((key, meVariance) in variances) {
                    for ((otherKey, otherVariance) in other.variances) {
                        val meCollapsed = meVariance.collapse()
                        val otherCollapsed = otherVariance.collapse()

                        val myImportance = key.importance()
                        val otherImportance = otherKey.importance()

                        val baseMultiplier = if (myImportance >= otherImportance) {
                            meVariance.multiplier.multiply(otherCollapsed)
                        } else {
                            otherVariance.multiplier.multiply(meCollapsed)
                        }

                        val baseRestrictor = if (myImportance >= otherImportance) {
                            meVariance.restrictor
                        } else {
                            otherVariance.restrictor
                        }

                        val newMultiplier = if (key == otherKey) {
                            baseMultiplier.intersect(ind.positiveNumbersAndZero())
                        } else {
                            baseMultiplier
                        }

                        val baseKey = if (myImportance >= otherImportance) key else otherKey

                        newVariances.compute(baseKey) { _, set ->
                            Variance(
                                ind,
                                multiplier = set?.multiplier?.add(newMultiplier) ?: newMultiplier,
                                restrictor = set?.restrictor?.intersect(baseRestrictor) ?: baseRestrictor
                            )
                        }
                    }
                }

                return newFromVariances(ind, newVariances)
            }

            DIVISION -> {
                if (other.isOne()) {
                    return this
                }

                // Division is going to be really hard to get right due to order-of-operations.
                TODO("DIVISION :(")
            }

            MODULO -> {
                val meCollapsed = this.collapse()
                val otherCollapsed = other.collapse()

                return newFromConstant(
                    meCollapsed.arithmeticOperation(otherCollapsed, MODULO)
                )
            }
        }
    }

    fun comparisonOperation(
        other: NumberVariances<T>,
        operation: ComparisonOp,
    ): BooleanVariances =
        // We could maybe do something smarter here long-term, but this'll do for now.
        collapse().comparisonOperation(other.collapse(), operation).toConstVariance().into()

    fun generateConstraintsFrom(
        other: NumberVariances<T>,
        comp: ComparisonOp
    ): Constraints {
        val allKeys = (variances.keys + other.variances.keys).filter { !it.isEphemeral() }

        var constraints = Constraints.completelyUnconstrained()

        for (key in allKeys) {
            val myKeyMultiplier = variances[key]?.multiplier ?: ind.onlyZeroSet()
            val otherKeyMultiplier = other.variances[key]?.multiplier ?: ind.onlyZeroSet()

            fun <T : Number> extra(keyInd: NumberSetIndicator<T>) {
                // Move all the keys onto the left
                val coefficient = myKeyMultiplier.subtract(otherKeyMultiplier)
                    .cast(keyInd)!!.into()

                val lhsConstant =
                    newFromVariances(ind, variances.filter { it.key != key })
                        .collapse()
                        .cast(keyInd)!!.into()
                val rhsConstant =
                    newFromVariances(ind, other.variances.filter { it.key != key })
                        .collapse()
                        .cast(keyInd)!!.into()

                val constant = rhsConstant.subtract(lhsConstant)

                if (coefficient.isZero()) {
                    // The key has cancelled itself out, this is now an all-or-nothing situation:
                    // either the constraint is met, or it isn't.
                    // The equation at this point looks like `0x blah constant`
                    // So we can just check the constant against zero.
                    val meetsConstraint = keyInd.onlyZeroSet().comparisonOperation(constant, comp)
                    constraints = when (meetsConstraint) {
                        BooleanSet.BOTH, BooleanSet.TRUE -> constraints.withConstraint(key, keyInd.newFullSet())
                        BooleanSet.FALSE, BooleanSet.NEITHER -> constraints.withConstraint(key, keyInd.newEmptySet())
                    }
                } else {
                    val shouldFlip = coefficient.comparisonOperation(keyInd.onlyZeroSet(), ComparisonOp.LESS_THAN)
                    val rhs = constant.divide(coefficient)
                    val constraint = when (shouldFlip) {
                        BooleanSet.TRUE -> rhs.getSetSatisfying(comp.flip())
                        BooleanSet.FALSE -> rhs.getSetSatisfying(comp)
                        BooleanSet.BOTH -> rhs.getSetSatisfying(comp)
                            .union(rhs.getSetSatisfying(comp.flip()))

                        BooleanSet.NEITHER -> throw IllegalStateException("Condition is neither true nor false!")
                    }

                    constraints = constraints.withConstraint(key, constraint)
                }
            }

            extra(key.ind as NumberSetIndicator<*>)
        }

        return constraints
    }

    fun evaluateLoopingRange(
        changeTerms: ConstraintSolver.CollectedTerms<T>,
        valid: NumberSet<T>
    ): NumberVariances<T> = TODO("Not yet implemented")
}