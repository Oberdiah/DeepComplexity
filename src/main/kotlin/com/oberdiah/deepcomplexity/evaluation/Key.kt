package com.oberdiah.deepcomplexity.evaluation

import com.oberdiah.deepcomplexity.staticAnalysis.Indicator

sealed class Key() {
    abstract val ind: Indicator<*>

    /**
     * Used to allow us to equate expressions.
     */
    data class ExpressionKey(val expr: Expr<*>) : Key() {
        override val ind: Indicator<*>
            get() = expr.ind

        override fun toString(): String = ExprToString.toExprKeyString(expr)
    }

    /**
     * Purely used to represent the constant value in a NumberVariance
     */
    object ConstantKey : Key() {
        override val ind: Indicator<*>
            get() = throw IllegalStateException("Constant keys don't have a type.")

        override fun toString(): String = "C"
    }

    fun isAutogenerated(): Boolean = isConstant() || isExpr()
    open fun isConstant(): Boolean = this is ConstantKey
    fun isExpr(): Boolean = this is ExpressionKey

    /**
     * When multiplying, we need to decide which one gets to live on.
     */
    fun importance(): Int {
        return when (this) {
            is VariableKey -> 6
            is QualifiedFieldKey -> 5
            is VariableExpr.KeyBackreference<*> -> 4
            is ThisKey -> 3
            is ReturnKey -> 2
            is ExpressionKey -> 1
            is ConstantKey -> 0
        }
    }
}