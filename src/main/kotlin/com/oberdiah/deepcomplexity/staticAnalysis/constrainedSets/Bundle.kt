package com.oberdiah.deepcomplexity.staticAnalysis.constrainedSets

import com.oberdiah.deepcomplexity.evaluation.Key
import com.oberdiah.deepcomplexity.evaluation.ExprEvaluate
import com.oberdiah.deepcomplexity.staticAnalysis.Indicator
import com.oberdiah.deepcomplexity.staticAnalysis.sets.ISet
import com.oberdiah.deepcomplexity.staticAnalysis.variances.NumberVariances
import com.oberdiah.deepcomplexity.staticAnalysis.variances.Variances
import org.jetbrains.kotlin.analysis.utils.collections.mapToSet

/**
 * This is the set of possible values an expression can take, with their constraints.
 *
 * For example, after the code
 * ```
 * int x = 0;
 * if (a * 2 > 5 && b < 10) {
 *     x = 5;
 * }
 * ```
 * x would be a BundleSet with the following bundles:
 * [
 *     {bundle: {0}, constraints: {a > 5/2, b < 10}},
 *     {bundle: {5}, constraints: {a <= 5/2, b >= 10}}
 * ]
 *
 * Now, when an operation is performed between two BundleSets we effectively do an O(n^2) operation,
 * running each bundle against each other bundle.
 *
 * NOTE: The bundle's constraints are not necessarily mutually exclusive and should be considered
 * OR'd together. Take, for example,
 * ```
 * if (a > 5 || (a > 10 && b > 15)) {
 * ```
 */
class Bundle<T : Any> private constructor(
    val ind: Indicator<T>,
    val variances: Set<ConstrainedVariances<T>>
) {
    init {
        require(variances.size < 50) {
            "Bundle has far too many variances: ${variances.size} ($variances)"
        }
    }

    companion object {
        fun <T : Any> unconstrained(bundle: Variances<T>): Bundle<T> {
            return Bundle(
                bundle.ind,
                setOf(
                    ConstrainedVariances.new(bundle, Constraints.completelyUnconstrained())
                )
            )
        }

        fun <T : Any> constrained(variances: Variances<T>, constraints: Constraints): Bundle<T> {
            return Bundle(
                variances.ind,
                setOf(
                    ConstrainedVariances.new(variances, constraints)
                )
            )
        }
    }

    @ConsistentCopyVisibility
    data class ConstrainedVariances<T : Any> private constructor(
        val variances: Variances<T>,
        val constraints: Constraints
    ) {
        companion object {
            fun <T : Any> new(variances: Variances<T>, constraints: Constraints): ConstrainedVariances<T> {
                return ConstrainedVariances(variances, constraints)
            }
        }

        override fun toString(): String {
            return toDebugString()
        }

        fun reduceAndSimplify(scope: ExprEvaluate.Scope): ConstrainedVariances<T> {
            return ConstrainedVariances(
                variances.reduceAndSimplify(scope, constraints),
                constraints.reduceAndSimplify(scope)
            )
        }

        fun toDebugString(): String {
            if (constraints.isUnconstrained()) {
                return variances.toDebugString(constraints)
            }
            val varsTracking = variances.varsTracking().filter { !it.isAutogenerated() }
            val constraintsToPrint = constraints.constraints.entries.filter { !varsTracking.contains(it.key) }

            if (constraintsToPrint.isEmpty()) {
                return "(${variances.toDebugString(constraints)})"
            }

            val variancesStr = variances.toDebugString(Constraints.completelyUnconstrained())
            val constraintsStr = constraintsToPrint.joinToString { "${it.key}[${it.value}]" }
            return "(${variancesStr} | $constraintsStr)"
        }
    }

    override fun toString(): String {
        return toDebugString()
    }

    /**
     * Might return additional information beyond simply what the set contains.
     */
    fun toDebugString(): String {
        if (variances.size == 1) {
            return variances.first().toDebugString()
        }

        return variances.joinToString {
            it.toDebugString()
        }
    }

    fun reduceAndSimplify(scope: ExprEvaluate.Scope): Bundle<T> {
        return Bundle(ind, variances.mapToSet { it.reduceAndSimplify(scope) })
    }

    fun union(other: Bundle<T>): Bundle<T> {
        return Bundle(ind, variances.union(other.variances))
    }

    fun <Q : Any> unaryMapAndUnion(
        newInd: Indicator<Q>,
        op: (Variances<T>, Constraints) -> Bundle<Q>
    ): Bundle<Q> =
        Bundle(newInd, variances.flatMap { oldVariances ->
            op(oldVariances.variances, oldVariances.constraints).variances.mapNotNull { newVariances ->
                val newConstraints = oldVariances.constraints.and(newVariances.constraints)

                if (newConstraints.unreachable) {
                    null
                } else {
                    if (oldVariances.constraints.isUnconstrained()) {
                        // No need to combine the constraints as we've got nothing new to add,
                        // we can just return the new bundle
                        newVariances
                    } else {
                        ConstrainedVariances.new(newVariances.variances, newConstraints)
                    }
                }
            }
        }.toSet())


    fun performUnaryOperation(op: (Variances<T>) -> Variances<T>): Bundle<T> = unaryMap(ind, op)

    fun <Q : Any> unaryMap(newInd: Indicator<Q>, op: (Variances<T>) -> Variances<Q>): Bundle<Q> {
        return Bundle(newInd, variances.mapToSet {
            ConstrainedVariances.new(op(it.variances), it.constraints)
        })
    }

    fun performBinaryOperation(
        other: Bundle<T>,
        exprKey: Key,
        op: (Variances<T>, Variances<T>, Constraints) -> Variances<T>
    ): Bundle<T> =
        binaryMapToVariances(ind, other, exprKey, op)

    fun <Q : Any> binaryMapToVariances(
        newInd: Indicator<Q>,
        other: Bundle<T>,
        exprKey: Key,
        op: (Variances<T>, Variances<T>, Constraints) -> Variances<Q>
    ): Bundle<Q> {
        require(ind == other.ind)

        val newBundles = mutableSetOf<ConstrainedVariances<Q>>()
        for (myBundle in variances) {
            for (otherBundle in other.variances) {
                val newConstraints = myBundle.constraints.and(otherBundle.constraints)

                if (newConstraints.unreachable) continue

                // Only do the fun optimisation if we were tracking something beforehand, otherwise we're just
                // going to start tracking a constant for no reason.
                val wereTrackingSomething =
                    (myBundle.variances.varsTracking() + otherBundle.variances.varsTracking()).isNotEmpty()

                val newVariances = op(myBundle.variances, otherBundle.variances, newConstraints)

                if (newVariances.varsTracking().isEmpty()
                    && wereTrackingSomething
                    && newVariances is NumberVariances<*>
                ) {
                    // If the new variance isn't tracking anything, we can help it out a bit
                    // by creating a new constraint around it and making it track the
                    // expression key itself. This allows us to continue tracking things to a
                    // limited degree even when the operation demolished our typical variance
                    // tracking.
                    val newConstraints = newConstraints.withConstraint(
                        exprKey,
                        newVariances.collapse(newConstraints)
                    )
                    newBundles.add(ConstrainedVariances.new(newInd.newVariance(exprKey), newConstraints))
                } else {
                    newBundles.add(ConstrainedVariances.new(newVariances, newConstraints))
                }
            }
        }

        return Bundle(newInd, newBundles)
    }

    fun <Q : Any> binaryMap(
        other: Bundle<T>,
        op: (Variances<T>, Variances<T>, Constraints) -> Q
    ): List<Q> {
        val listOut = mutableListOf<Q>()
        for (myBundle in variances) {
            for (otherBundle in other.variances) {
                val newConstraints = myBundle.constraints.and(otherBundle.constraints)
                if (newConstraints.unreachable) continue
                listOut.add(op(myBundle.variances, otherBundle.variances, newConstraints))
            }
        }
        return listOut
    }

    /**
     * The expression you provide is converted into a set of constraints and then
     * combined with this bundle set.
     */
    fun constrainWith(scope: ExprEvaluate.Scope): Bundle<T> {
        if (scope.isUnconstrained()) {
            return this
        }

        return Bundle(ind, variances.flatMap { bundle ->
            scope.constraints.map { constraint ->
                ConstrainedVariances.new(bundle.variances, bundle.constraints.and(constraint))
            }
        }.toSet())
    }

    /**
     * Collapses the full set of bundles into a single bundle, treating the constraints as an OR.
     *
     * @return A single bundle representing the collapsed state of the current bundle set.
     */
    fun collapse(): ISet<T> {
        if (variances.isEmpty()) {
            return ind.newEmptySet()
        }

        return variances.fold(ind.newEmptySet()) { acc, bundle ->
            acc.union(bundle.variances.collapse(bundle.constraints))
        }
    }

    fun <Q : Any> cast(indicator: Indicator<Q>): Bundle<Q>? {
        if (indicator == ind) {
            // Safety: The indicators are the same, so the cast is valid
            @Suppress("UNCHECKED_CAST")
            return this as Bundle<Q>
        }

        val cast = Bundle(
            indicator, variances.mapToSet {
                ConstrainedVariances.new(it.variances.cast(indicator, it.constraints) ?: return null, it.constraints)
            }
        )
        return cast
    }
}