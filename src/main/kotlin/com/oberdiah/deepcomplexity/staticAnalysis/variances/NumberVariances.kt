package com.oberdiah.deepcomplexity.staticAnalysis.variances

import com.oberdiah.deepcomplexity.context.Key
import com.oberdiah.deepcomplexity.evaluation.BinaryNumberOp
import com.oberdiah.deepcomplexity.evaluation.BinaryNumberOp.*
import com.oberdiah.deepcomplexity.evaluation.ComparisonOp
import com.oberdiah.deepcomplexity.evaluation.ExprEvaluate
import com.oberdiah.deepcomplexity.staticAnalysis.Indicator
import com.oberdiah.deepcomplexity.staticAnalysis.NumberIndicator
import com.oberdiah.deepcomplexity.staticAnalysis.constrainedSets.Constraints
import com.oberdiah.deepcomplexity.staticAnalysis.sets.BooleanSet
import com.oberdiah.deepcomplexity.staticAnalysis.sets.NumberSet
import com.oberdiah.deepcomplexity.staticAnalysis.sets.into
import com.oberdiah.deepcomplexity.utilities.Functional

/**
 * Think of this as a linear equation like the form: `2x + 3y + 4z + c`
 * where the keys are the variables (x, y, z) and the values are the multipliers (2, 3, 4).
 * The constant (c) is represented by the Constant key.
 *
 * Now, we don't store the constraints here; they come in from outside, so we can't calculate a full
 * range from this alone. So intuitively, when we want to collapse, we take the constraints for each key
 * and multiply them by the multiplier, and then add them all together.
 *
 * The way this works with casting is that if the key is not of the base indicator type, we'll assume
 * casting is the first thing that happens.
 *
 * This means we need to be able to figure out whether an equation *could* have wrapped, and if so,
 * we have no choice but to collapse it. Simple tracking with a constant of 1,
 * such as `Variances<Short>(x(short): 1)`, can be guaranteed not to wrap, so that stuff is straightforward.
 *
 * However, `Variances<Short>(x(short): 2)`, and `Variances<Short>(x(short): 1, y(short): 1)` both may have
 * ended up wrapping, so with a naive implementation they'd need to be collapsed. Whether I actually
 * end up doing that or not remains to be seen.
 */
@ConsistentCopyVisibility
data class NumberVariances<T : Number> private constructor(
    override val ind: NumberIndicator<T>,
    private val multipliers: Map<Key, NumberSet<T>> = mapOf()
) : Variances<T> {
    override fun toString(): String {
        return multipliers.entries.joinToString(", ") { (key, multiplier) ->
            "$key: ($multiplier)"
        }
    }

    companion object {
        fun <T : Number> newFromConstant(constant: NumberSet<T>): NumberVariances<T> =
            NumberVariances(constant.ind, mapOf(Key.ConstantKey to constant))

        fun <T : Number> newFromVariance(ind: NumberIndicator<T>, key: Key): NumberVariances<T> =
            NumberVariances(ind, mapOf(key to ind.onlyOneSet()))
    }

    override fun toDebugString(constraints: Constraints): String {
        return if (varsTracking().isEmpty()) {
            multipliers[Key.ConstantKey].toString() ?: "0"
        } else {
            multipliers.entries.filter { (k, m) -> !(m.isZero() && k.isAutogenerated()) }
                .joinToString(" + ") { (key, multiplier) ->
                    val multiplierStr = if (multiplier.isOne() && !key.isConstant()) "" else "$multiplier"
                    val keyStr = if (key.isConstant()) "" else key.toString()
                    val constraint = constraints.getConstraint(ind, key)
                    val constraintStr = if (constraint.isFull()) "" else "[$constraint]"

                    "$multiplierStr$keyStr$constraintStr"
                }
        }
    }

    override fun varsTracking(): Collection<Key> {
        return multipliers.keys.filter { !it.isConstant() }
    }

    override fun reduceAndSimplify(scope: ExprEvaluate.Scope, constraints: Constraints): Variances<T> {
        val newMultipliers = multipliers.entries.map { (key, v) ->
            if (scope.shouldKeep(key)) {
                key to v
            } else {
                Key.ConstantKey to v.multiply(grabConstraint(constraints, key))
            }
        }
            // If multiple keys got turned into the constant key, we need to combine them.
            .groupingBy { it.first }
            .fold(ind.onlyZeroSet()) { acc, (_, v) -> acc.add(v) }

        return NumberVariances(ind, newMultipliers)
    }

    fun grabConstraint(constraints: Constraints, key: Key): NumberSet<T> {
        return if (key.isConstant()) {
            // Constants don't have any variance or constraints,
            // so the 'variable', if you can call it that, is always constrained to exactly 1.
            ind.onlyOneSet()
        } else {
            constraints.getConstraint(ind, key).into()
        }
    }

    /**
     * Collapse the multipliers into a single set of values.
     * Requires constraints because a NumberVariance on its own doesn't contain
     * all the information it needs alone.
     */
    override fun collapse(constraints: Constraints): NumberSet<T> =
        multipliers.entries.fold(ind.onlyZeroSet()) { acc, (key, multiplier) ->
            acc.add(multiplier.multiply(grabConstraint(constraints, key)))
        }

    override fun <Q : Any> cast(newInd: Indicator<Q>, constraints: Constraints): Variances<Q>? {
        if (newInd !is NumberIndicator<*>) {
            return null
        }
        if (newInd == ind) {
            // Safety: newInd == ind.
            @Suppress("UNCHECKED_CAST")
            return this as Variances<Q>
        }

        fun <OutT : Number> extra(newInd: NumberIndicator<OutT>): NumberVariances<OutT>? {
            // If we're only tracking a single variable with a multiplier of 1, and there's no constant offset,
            // we can safely cast ourselves directly to the new indicator.
            if (multipliers.size == 1) {
                if (multipliers.values.first().isOne() && !multipliers.keys.first().isConstant()) {
                    return NumberVariances(newInd, mapOf(multipliers.keys.first() to newInd.onlyOneSet()))
                }
            }

            val q = collapse(constraints).cast(newInd)?.into() ?: return null
            return newFromConstant(q)
        }

        @Suppress("UNCHECKED_CAST") // Safety: Trivially true by checking the signature of extra().
        return extra(newInd) as Variances<Q>?
    }

    fun isOne(constraints: Constraints): Boolean = collapse(constraints).isOne()

    fun negate(): NumberVariances<T> {
        return NumberVariances(ind, multipliers.mapValues { (_, multiplier) ->
            multiplier.negate()
        })
    }

    fun arithmeticOperation(
        other: NumberVariances<T>,
        operation: BinaryNumberOp,
        constraints: Constraints
    ): NumberVariances<T> {
        when (operation) {
            ADDITION, SUBTRACTION -> {
                return NumberVariances(
                    ind, Functional.mergeMapsWithBlank(
                        multipliers,
                        other.multipliers,
                        ind.onlyZeroSet()
                    ) { me, other ->
                        if (operation == ADDITION) {
                            me.add(other)
                        } else {
                            me.subtract(other)
                        }
                    })
            }

            MULTIPLICATION -> {
                val newMultipliers = mutableMapOf<Key, NumberSet<T>>()

                for ((key, meMultiplier) in multipliers) {
                    for ((otherKey, otherMultiplier) in other.multipliers) {
                        val meCollapsed = meMultiplier.multiply(grabConstraint(constraints, key))
                        val otherCollapsed = otherMultiplier.multiply(grabConstraint(constraints, otherKey))

                        val myImportance = key.importance()
                        val otherImportance = otherKey.importance()

                        val newMultiplier = if (myImportance >= otherImportance) {
                            meMultiplier.multiply(otherCollapsed)
                        } else {
                            otherMultiplier.multiply(meCollapsed)
                        }

                        // In regard to multiplying a key with itself, we have two choices:
                        // 1.  We want to ensure the value is positive. The variable by default
                        //     may be negative, so if we want this, we'll have to shove it into a constant,
                        //     losing tracking.
                        //     Well, that or create a brand-new system where we can track special constraints
                        //     within our keys. (Note, could be fun, not completely out the window.)
                        //     Wait, maybe we investigate that idea further, that sounds cool.
                        // 2.  We treat them as two separate keys and collapse one half.
                        //     This allows us to maintain part of the idea that we're still dependent on the variable.
                        //     So that down the road if we multiply by something else that is also dependent on the
                        //     variable, some of that information is kicking around to infer with.

                        val baseKey = if (myImportance >= otherImportance) key else otherKey

                        newMultipliers.compute(baseKey) { _, set ->
                            set?.add(newMultiplier) ?: newMultiplier
                        }
                    }
                }

                return NumberVariances(ind, newMultipliers)
            }

            DIVISION -> {
                if (other.isOne(constraints)) {
                    return this
                }

                val newMultipliers = mutableMapOf<Key, NumberSet<T>>()

                for ((key, meMultiplier) in multipliers) {
                    for ((otherKey, otherMultiplier) in other.multipliers) {
                        val meCollapsed = meMultiplier.multiply(grabConstraint(constraints, key))
                        val otherCollapsed = otherMultiplier.multiply(grabConstraint(constraints, otherKey))

                        val newValue = meCollapsed.divide(otherCollapsed)

                        newMultipliers.compute(key) { _, set ->
                            set?.add(newValue) ?: newValue
                        }
                    }
                }

                return NumberVariances(ind, newMultipliers)
            }

            MODULO -> {
                val meCollapsed = this.collapse(constraints)
                val otherCollapsed = other.collapse(constraints)

                return newFromConstant(
                    meCollapsed.arithmeticOperation(otherCollapsed, MODULO)
                )
            }
        }
    }

    override fun generateConstraintsFrom(
        other: Variances<T>,
        comparisonOp: ComparisonOp,
        constraints: Constraints
    ): Constraints {
        val other = other.into()
        val allKeys = (multipliers.keys + other.multipliers.keys).filter { !it.isConstant() }

        var constraints = constraints

        for (key in allKeys) {
            val myKeyMultiplier = multipliers[key] ?: ind.onlyZeroSet()
            val otherKeyMultiplier = other.multipliers[key] ?: ind.onlyZeroSet()

            // Move all the keys onto the left
            val lhsCoefficient = myKeyMultiplier.subtract(otherKeyMultiplier)

            // Collapse all non-our-key constants into a single value, and move them to the right.
            val collapsedLhsBeforeMove =
                NumberVariances(ind, multipliers.filter { it.key != key })
                    .collapse(constraints)
            val collapsedRhsBeforeMove =
                NumberVariances(ind, other.multipliers.filter { it.key != key })
                    .collapse(constraints)

            val rhsConstant = collapsedRhsBeforeMove.subtract(collapsedLhsBeforeMove)

            if (lhsCoefficient.isZero()) {
                // The key has cancelled itself out, this is now an all-or-nothing situation:
                // either the constraint is met, or it isn't.
                // The equation at this point looks like `0x op constant`
                // So we can just check the constant against zero.
                val meetsConstraint = ind.onlyZeroSet().comparisonOperation(rhsConstant, comparisonOp)
                constraints = when (meetsConstraint) {
                    BooleanSet.BOTH, BooleanSet.TRUE -> constraints.withConstraint(key, key.ind.newFullSet())
                    BooleanSet.FALSE, BooleanSet.NEITHER -> constraints.withConstraint(key, key.ind.newEmptySet())
                }
            } else {
                val shouldFlip = lhsCoefficient.comparisonOperation(ind.onlyZeroSet(), ComparisonOp.LESS_THAN)
                val rhs = rhsConstant.divide(lhsCoefficient)
                val constraint = when (shouldFlip) {
                    BooleanSet.TRUE -> rhs.getSetSatisfying(comparisonOp.flip())
                    BooleanSet.FALSE -> rhs.getSetSatisfying(comparisonOp)
                    BooleanSet.BOTH -> rhs.getSetSatisfying(comparisonOp)
                        .union(rhs.getSetSatisfying(comparisonOp.flip()))

                    BooleanSet.NEITHER -> throw IllegalStateException("Condition is neither true nor false!")
                }

                // I'm slightly unsure about this cast.
                constraints = constraints.withConstraint(key, constraint.clampCast(key.ind)!!)
            }
        }

        return constraints
    }
}