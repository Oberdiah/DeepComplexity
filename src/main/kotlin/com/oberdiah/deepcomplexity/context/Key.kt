package com.oberdiah.deepcomplexity.context

import com.oberdiah.deepcomplexity.evaluation.Expr
import com.oberdiah.deepcomplexity.evaluation.ExprToString
import com.oberdiah.deepcomplexity.staticAnalysis.Indicator

sealed interface Key {
    val ind: Indicator<*>

    /**
     * Used to allow us to equate expressions.
     */
    data class ExpressionKey(val expr: Expr<*>) : Key {
        override val ind: Indicator<*>
            get() = expr.ind

        override fun toString(): String = ExprToString.toExprKeyString(expr)
    }

    /**
     * Purely used to represent the constant value in a NumberVariance
     */
    object ConstantKey : Key {
        override val ind: Indicator<*>
            get() = throw IllegalStateException("Constant keys don't have a type.")

        override fun toString(): String = "C"
    }

    fun isAutogenerated(): Boolean = isConstant() || isExpr()
    fun isConstant(): Boolean = this is ConstantKey
    fun isExpr(): Boolean = this is ExpressionKey

    /**
     * When multiplying, we need to decide which one gets to live on.
     */
    fun importance(): Int {
        return when (this) {
            is VariableKey -> 2
            is ExpressionKey -> 1
            is ConstantKey -> 0
        }
    }
}